<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Map Stream Overlay</title>
	<style>
		* {
			margin: 0;
			padding: 0;
			box-sizing: border-box;
		}

		body {
			background: #000000;
			width: 100vw;
			height: 100vh;
			overflow: hidden;
			display: flex;
			justify-content: center;
			align-items: center;
		}

		#minimap-frame {
			width: 100vh;
			aspect-ratio: 9/16;
			position: relative;
			/* Reduced filter intensity for better visibility */
			filter: drop-shadow(0 0 10px rgba(0, 255, 200, 0.2));
		}

		#map-container {
			width: 100%;
			height: 100%;
			position: relative;
		}

		#map {
			width: 100%;
			height: 100%;
			position: relative;
		}

		#grid-overlay {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			pointer-events: none;
			background-image:
				repeating-linear-gradient(0deg,
					transparent,
					transparent 49px,
					rgba(0, 255, 200, 0.05) 49px,
					rgba(0, 255, 200, 0.05) 50px),
				repeating-linear-gradient(90deg,
					transparent,
					transparent 49px,
					rgba(0, 255, 200, 0.05) 49px,
					rgba(0, 255, 200, 0.05) 50px);
			z-index: 10;
		}

		#frame-border {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			z-index: 20;
			pointer-events: none;
		}

		#scan-line {
			position: absolute;
			top: 50%;
			left: 50%;
			width: 100%;
			height: 2px;
			background: linear-gradient(90deg,
					transparent 0%,
					rgba(0, 255, 200, 0.1) 45%,
					rgba(0, 255, 200, 0.3) 50%,
					rgba(0, 255, 200, 0.1) 55%,
					transparent 100%);
			transform-origin: center;
			animation: radar-sweep 4s linear infinite;
			z-index: 12;
			opacity: 0.5;
		}

		/* Subtle noise effect */
		#noise-overlay {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			opacity: 0.02;
			z-index: 11;
			pointer-events: none;
			background-image:
				repeating-linear-gradient(45deg,
					transparent,
					transparent 2px,
					rgba(255, 255, 255, 0.03) 2px,
					rgba(255, 255, 255, 0.03) 4px);
		}

		/* Lighter vignette effect */
		#vignette-overlay {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			pointer-events: none;
			background: radial-gradient(ellipse at center,
					transparent 0%,
					transparent 70%,
					rgba(0, 0, 0, 0.2) 85%,
					rgba(0, 0, 0, 0.4) 100%);
			z-index: 15;
		}

		@keyframes radar-sweep {
			from {
				transform: translate(-50%, -50%) rotate(0deg);
			}

			to {
				transform: translate(-50%, -50%) rotate(360deg);
			}
		}
	</style>
</head>

<body>
	<div id="minimap-frame">
		<div id="map-container">
			<div id="map"></div>
			<div id="grid-overlay"></div>
			<div id="scan-line"></div>
			<div id="noise-overlay"></div>
			<div id="vignette-overlay"></div>
		</div>
		<svg id="frame-border" viewBox="0 0 100 100" preserveAspectRatio="none">
			<path d="M 50,5 L 85,25 L 85,75 L 50,95 L 15,75 L 15,25 Z" fill="none" stroke="rgba(0, 255, 200, 0.6)"
				stroke-width="0.5" />
		</svg>
	</div>

	<script>
		// Replace with your actual Google Maps API key
		const GOOGLE_MAPS_API_KEY = 'AIzaSyATFVb_BO1HhFGZ8m0PMe7uy2F4T2KW6ZQ';
		const UPDATES_URL = '{{UPDATE_URL}}';

		// Configuration
		const INITIAL_ZOOM = 20; // Good balance for seeing detail and area
		const MIN_ZOOM = 14; // Minimum zoom when fitting bounds
		const POLL_INTERVAL = 500; // Poll for updates every second

		let map;
		let markers = {};
		let userLocation = null;
		let animationInterval;
		const UPDATE_INTERVAL = 50; // Update every 100ms for smooth movement

		// Initial coordinates - loaded from server
		let coordinates = [];

		// Color palette for coordinate points
		const COLORS = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFA07A', '#98D8C8', '#F7B731', '#5F27CD'];

		// Load Google Maps API
		function loadGoogleMaps() {
			const script = document.createElement('script');
			script.src = `https://maps.googleapis.com/maps/api/js?key=${GOOGLE_MAPS_API_KEY}&callback=initMap`;
			script.async = true;
			script.defer = true;
			document.head.appendChild(script);
		}

		// Fetch coordinates from server
		async function fetchCoordinates() {
			try {
				const response = await fetch(UPDATES_URL);
				if (!response.ok) {
					throw new Error(`HTTP error! status: ${response.status}`);
				}
				const data = await response.json();
				return parseCoordinatesFromResponse(data);
			} catch (error) {
				console.error('Error fetching coordinates:', error);
				return [];
			}
		}

		// Parse coordinates from the API response
		function parseCoordinatesFromResponse(data) {
			if (!data.streams) return [];

			// Filter for video streams only
			const videoStreams = data.streams.filter(stream => stream.mediaType === 'video');

			const coords = [];
			videoStreams.forEach((stream, index) => {
				if (!stream.appData) return;

				try {
					const appData = JSON.parse(stream.appData);
					if (appData.latitude !== undefined && appData.longitude !== undefined) {
						// Find existing coordinate or create new one
						const existingCoord = coordinates.find(c => c.id === stream.streamName);
						const color = existingCoord ? existingCoord.color : COLORS[index % COLORS.length];

						coords.push({
							id: stream.streamName,
							latitude: appData.latitude,
							longitude: appData.longitude,
							color: color,
							velocity: existingCoord ? existingCoord.velocity : { lat: 0, lng: 0 }
						});
					}
				} catch (error) {
					console.error('Error parsing appData for stream:', stream.streamName, error);
				}
			});

			if (coords[0]) {
				console.log(coords[0].latitude, coords[0].longitude);
			}
			return coords;
		}

		// Initialize the map
		async function initMap() {
			// Load initial coordinates
			coordinates = await fetchCoordinates();

			// Determine initial center
			if (coordinates.length > 0) {
				// Center on first coordinate
				userLocation = {
					lat: coordinates[0].latitude,
					lng: coordinates[0].longitude
				};
				setupMap(userLocation);
			} else {
				// Try to get user's location or use default
				if (navigator.geolocation) {
					navigator.geolocation.getCurrentPosition(
						(position) => {
							userLocation = {
								lat: position.coords.latitude,
								lng: position.coords.longitude
							};
							setupMap(userLocation);
						},
						(error) => {
							console.warn('Geolocation failed:', error);
							userLocation = { lat: 32.772652, lng: -117.246941 };
							setupMap(userLocation);
						}
					);
				} else {
					userLocation = { lat: 32.772652, lng: -117.246941 };
					setupMap(userLocation);
				}
			}

			// Start polling for updates
			startPolling();
		}

		function setupMap(center) {
			map = new google.maps.Map(document.getElementById('map'), {
				center: center,
				zoom: INITIAL_ZOOM,
				mapTypeId: 'roadmap',
				disableDefaultUI: true,
				gestureHandling: 'none',
				keyboardShortcuts: false,
				clickableIcons: false,
				disableDoubleClickZoom: true,
				scrollwheel: false,
				backgroundColor: '#0a0f14',
				styles: [
					// Remove all labels for cleaner look
					{ elementType: 'labels', stylers: [{ visibility: 'off' }] },

					// Base geometry - dark blue/gray but visible
					{ elementType: 'geometry', stylers: [{ color: '#1a2530' }] },

					// Water - much darker blue for strong contrast
					{ featureType: 'water', elementType: 'geometry', stylers: [{ color: '#0a1015' }] },

					// Land/terrain - medium gray
					{ featureType: 'landscape', elementType: 'geometry', stylers: [{ color: '#25303a' }] },

					// Man-made landscape - lighter gray/tan for clear distinction
					{ featureType: 'landscape.man_made', elementType: 'geometry', stylers: [{ color: '#3a4550' }] },

					// Parks - distinct green tint
					{ featureType: 'poi.park', elementType: 'geometry', stylers: [{ color: '#1a3020' }] },

					// Roads - visible medium gray
					{ featureType: 'road', elementType: 'geometry', stylers: [{ color: '#3a4550' }] },
					{ featureType: 'road', elementType: 'geometry.stroke', stylers: [{ color: '#252f3a', weight: 0.5 }] },

					// Highways brighter for visibility
					{ featureType: 'road.highway', elementType: 'geometry', stylers: [{ color: '#4a5565' }] },
					{ featureType: 'road.highway', elementType: 'geometry.stroke', stylers: [{ color: '#2a3540', weight: 0.5 }] },

					// Buildings - lighter to distinguish from natural terrain
					{ featureType: 'poi', elementType: 'geometry', stylers: [{ color: '#3a4555' }] },
					{ featureType: 'poi.business', elementType: 'geometry', stylers: [{ color: '#404a5a' }] },

					// Transit
					{ featureType: 'transit', elementType: 'geometry', stylers: [{ color: '#3a4555' }] },
					{ featureType: 'transit.station', elementType: 'geometry', stylers: [{ color: '#404a5a' }] },

					// Administrative boundaries - subtle but visible
					{ featureType: 'administrative', elementType: 'geometry.stroke', stylers: [{ color: '#4a5560', weight: 0.5 }] },
					{ featureType: 'administrative.land_parcel', elementType: 'geometry.stroke', stylers: [{ color: '#3a4550' }] }
				]
			});

			// Initialize coordinate markers
			updateMarkers();
		}

		function shrinkBounds(bounds, percentage) {
			const ne = bounds.getNorthEast();
			const sw = bounds.getSouthWest();

			// Calculate the dimensions
			const latRange = ne.lat() - sw.lat();
			const lngRange = ne.lng() - sw.lng();

			// Calculate the inset amount (10% = 0.1)
			const latInset = latRange * percentage;
			const lngInset = lngRange * percentage;

			// Create new bounds with the inset applied
			const newSW = new google.maps.LatLng(
				sw.lat() + latInset,
				sw.lng() + lngInset
			);
			const newNE = new google.maps.LatLng(
				ne.lat() - latInset,
				ne.lng() - lngInset
			);

			return new google.maps.LatLngBounds(newSW, newNE);
		}

		function updateMarkers() {
			// Check if any coordinate is outside current bounds
			const currentBounds = map.getBounds();
			let needsRefit = false;

			coordinates.forEach(coord => {
				const position = { lat: coord.latitude, lng: coord.longitude };

				// Check if this coordinate is outside current bounds
				if (currentBounds && !shrinkBounds(currentBounds, 0.1).contains(position)) {
					needsRefit = true;
				}

				if (markers[coord.id]) {
					// Smoothly update existing marker position
					markers[coord.id].setPosition(position);
				} else {
					// Create new marker with glow effect
					markers[coord.id] = new google.maps.Marker({
						position: position,
						map: map,
						title: coord.id,
						icon: {
							path: google.maps.SymbolPath.CIRCLE,
							scale: 8,
							fillColor: coord.color || '#FF6B6B',
							fillOpacity: 0.8,
							strokeColor: '#ffffff',
							strokeWeight: 1.5,
							strokeOpacity: 0.9
						}
					});
					// New markers always trigger refit
					needsRefit = true;
				}
			});

			// Only adjust map bounds if a marker went outside
			if (needsRefit) {
				fitMapToBounds();
			}
		}

		function fitMapToBounds() {
			const bounds = new google.maps.LatLngBounds();

			// Include all coordinate points
			coordinates.forEach(coord => {
				bounds.extend({ lat: coord.latitude, lng: coord.longitude });
			});

			map.fitBounds(bounds);

			// Keep minimum zoom for detail when auto-fitting bounds
			const listener = google.maps.event.addListener(map, 'idle', () => {
				if (map.getZoom() < MIN_ZOOM) {
					map.setZoom(MIN_ZOOM);
				}
				google.maps.event.removeListener(listener);
			});
		}

		// Poll for coordinate updates
		async function pollCoordinates() {
			const newCoordinates = await fetchCoordinates();

			// Update coordinates - replace entirely with new data
			coordinates = newCoordinates;

			// Remove markers that are no longer in the coordinate list
			const currentIds = new Set(coordinates.map(c => c.id));
			Object.keys(markers).forEach(id => {
				if (!currentIds.has(id)) {
					markers[id].setMap(null);
					delete markers[id];
				}
			});

			// Update remaining/new markers
			if (coordinates.length > 0) {
				updateMarkers();
			}
		}

		function startPolling() {
			// Poll for updates at regular intervals
			setInterval(pollCoordinates, POLL_INTERVAL);
		}

		// Initialize everything when the page loads
		window.onload = () => {
			loadGoogleMaps();
		};
	</script>
</body>

</html>