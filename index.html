<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Map Stream Overlay</title>
	<style>
		* {
			margin: 0;
			padding: 0;
			box-sizing: border-box;
		}

		body {
			background: #000000;
			width: 100vw;
			height: 100vh;
			overflow: hidden;
			display: flex;
			justify-content: center;
			align-items: center;
		}

		#minimap-frame {
			width: 100vh;
			aspect-ratio: 9/16;
			position: relative;
			/* Reduced filter intensity for better visibility */
			filter: drop-shadow(0 0 10px rgba(0, 255, 200, 0.2));
		}

		#map-container {
			width: 100%;
			height: 100%;
			position: relative;
		}

		#map {
			width: 100%;
			height: 100%;
			position: relative;
		}

		#grid-overlay {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			pointer-events: none;
			background-image:
				repeating-linear-gradient(0deg,
					transparent,
					transparent 49px,
					rgba(0, 255, 200, 0.05) 49px,
					rgba(0, 255, 200, 0.05) 50px),
				repeating-linear-gradient(90deg,
					transparent,
					transparent 49px,
					rgba(0, 255, 200, 0.05) 49px,
					rgba(0, 255, 200, 0.05) 50px);
			z-index: 10;
		}

		#frame-border {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			z-index: 20;
			pointer-events: none;
		}

		#scan-line {
			position: absolute;
			top: 50%;
			left: 50%;
			width: 100%;
			height: 2px;
			background: linear-gradient(90deg,
					transparent 0%,
					rgba(0, 255, 200, 0.1) 45%,
					rgba(0, 255, 200, 0.3) 50%,
					rgba(0, 255, 200, 0.1) 55%,
					transparent 100%);
			transform-origin: center;
			animation: radar-sweep 4s linear infinite;
			z-index: 12;
			opacity: 0.5;
		}

		/* Subtle noise effect */
		#noise-overlay {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			opacity: 0.02;
			z-index: 11;
			pointer-events: none;
			background-image:
				repeating-linear-gradient(45deg,
					transparent,
					transparent 2px,
					rgba(255, 255, 255, 0.03) 2px,
					rgba(255, 255, 255, 0.03) 4px);
		}

		/* Lighter vignette effect */
		#vignette-overlay {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			pointer-events: none;
			background: radial-gradient(ellipse at center,
					transparent 0%,
					transparent 70%,
					rgba(0, 0, 0, 0.2) 85%,
					rgba(0, 0, 0, 0.4) 100%);
			z-index: 15;
		}

		@keyframes radar-sweep {
			from {
				transform: translate(-50%, -50%) rotate(0deg);
			}

			to {
				transform: translate(-50%, -50%) rotate(360deg);
			}
		}
	</style>
</head>

<body>
	<div id="minimap-frame">
		<div id="map-container">
			<div id="map"></div>
			<div id="grid-overlay"></div>
			<div id="scan-line"></div>
			<div id="noise-overlay"></div>
			<div id="vignette-overlay"></div>
		</div>
		<svg id="frame-border" viewBox="0 0 100 100" preserveAspectRatio="none">
			<path d="M 50,5 L 85,25 L 85,75 L 50,95 L 15,75 L 15,25 Z" fill="none" stroke="rgba(0, 255, 200, 0.6)"
				stroke-width="0.5" />
		</svg>
	</div>

	<script>
		// Replace with your actual Google Maps API key
		const GOOGLE_MAPS_API_KEY = 'AIzaSyATFVb_BO1HhFGZ8m0PMe7uy2F4T2KW6ZQ';

		// Configuration
		const INITIAL_ZOOM = 20; // Good balance for seeing detail and area
		const MIN_ZOOM = 14; // Minimum zoom when fitting bounds

		let map;
		let markers = {};
		let userLocation = null;
		let animationInterval;
		const UPDATE_INTERVAL = 50; // Update every 100ms for smooth movement

		// Initial coordinates - tightly clustered
		let coordinates = [
			{
				id: 'foo',
				latitude: 32.772652,
				longitude: -117.246941,
				color: '#FF6B6B',
				velocity: { lat: 0, lng: 0 }
			},
			{
				id: 'bar',
				latitude: 32.77265205,
				longitude: -117.246941,
				color: '#4ECDC4',
				velocity: { lat: 0, lng: 0 }
			},
			{
				id: 'baz',
				latitude: 32.772652,
				longitude: -117.246941,
				color: '#45B7D1',
				velocity: { lat: 0, lng: 0 }
			},
			{
				id: 'qux',
				latitude: 32.7726521,
				longitude: -117.246941,
				color: '#96CEB4',
				velocity: { lat: 0, lng: 0 }
			}
		];

		// Load Google Maps API
		function loadGoogleMaps() {
			const script = document.createElement('script');
			script.src = `https://maps.googleapis.com/maps/api/js?key=${GOOGLE_MAPS_API_KEY}&callback=initMap`;
			script.async = true;
			script.defer = true;
			document.head.appendChild(script);
		}

		// Initialize the map
		function initMap() {
			// Try to get user's location
			if (navigator.geolocation) {
				navigator.geolocation.getCurrentPosition(
					(position) => {
						userLocation = {
							lat: position.coords.latitude,
							lng: position.coords.longitude
						};
						setupMap(userLocation);
						initializeCoordinatesNearUser();
					},
					(error) => {
						console.warn('Geolocation failed:', error);
						// Use default location (San Diego)
						userLocation = { lat: 32.772652, lng: -117.246941 };
						setupMap(userLocation);
					}
				);
			} else {
				// Browser doesn't support geolocation
				userLocation = { lat: 32.772652, lng: -117.246941 };
				setupMap(userLocation);
			}
		}

		function setupMap(center) {
			map = new google.maps.Map(document.getElementById('map'), {
				center: center,
				zoom: INITIAL_ZOOM,
				mapTypeId: 'roadmap',
				disableDefaultUI: true,
				gestureHandling: 'none',
				keyboardShortcuts: false,
				clickableIcons: false,
				disableDoubleClickZoom: true,
				scrollwheel: false,
				backgroundColor: '#0a0f14',
				styles: [
					// Remove all labels for cleaner look
					{ elementType: 'labels', stylers: [{ visibility: 'off' }] },

					// Base geometry - dark blue/gray but visible
					{ elementType: 'geometry', stylers: [{ color: '#1a2530' }] },

					// Water - dark blue but distinguishable
					{ featureType: 'water', elementType: 'geometry', stylers: [{ color: '#0e1824' }] },

					// Land/terrain - dark military green/gray
					{ featureType: 'landscape', elementType: 'geometry', stylers: [{ color: '#1f2b30' }] },
					{ featureType: 'landscape.man_made', elementType: 'geometry', stylers: [{ color: '#242f35' }] },

					// Parks - slightly lighter green
					{ featureType: 'poi.park', elementType: 'geometry', stylers: [{ color: '#263338' }] },

					// Roads - visible dark gray lines
					{ featureType: 'road', elementType: 'geometry', stylers: [{ color: '#2a3845' }] },
					{ featureType: 'road', elementType: 'geometry.stroke', stylers: [{ color: '#212a35', weight: 0.5 }] },

					// Highways slightly brighter
					{ featureType: 'road.highway', elementType: 'geometry', stylers: [{ color: '#334455' }] },
					{ featureType: 'road.highway', elementType: 'geometry.stroke', stylers: [{ color: '#1a2530', weight: 0.5 }] },

					// Buildings - visible but subtle
					{ featureType: 'poi', elementType: 'geometry', stylers: [{ color: '#283540' }] },
					{ featureType: 'poi.business', elementType: 'geometry', stylers: [{ color: '#2a3742' }] },

					// Transit
					{ featureType: 'transit', elementType: 'geometry', stylers: [{ color: '#2a3845' }] },
					{ featureType: 'transit.station', elementType: 'geometry', stylers: [{ color: '#283540' }] },

					// Administrative boundaries - subtle but visible
					{ featureType: 'administrative', elementType: 'geometry.stroke', stylers: [{ color: '#4a5560', weight: 0.5 }] },
					{ featureType: 'administrative.land_parcel', elementType: 'geometry.stroke', stylers: [{ color: '#3a4550' }] }
				]
			});

			// Initialize coordinate markers
			updateMarkers();

			// Start animation
			startAnimation();
		}

		function initializeCoordinatesNearUser() {
			// Place all coordinates in a tight cluster near the user
			const baseLat = userLocation.lat;
			const baseLng = userLocation.lng;

			// Very small offset for tight clustering (about 1-2 meters apart)
			coordinates = coordinates.map((coord, index) => {
				const offsetLat = (index % 2) * 0.00001 - 0.000005;
				const offsetLng = (Math.floor(index / 2)) * 0.00001 - 0.000005;

				return {
					...coord,
					latitude: baseLat + offsetLat,
					longitude: baseLng + offsetLng,
					velocity: { lat: 0, lng: 0 }
				};
			});
		}

		function shrinkBounds(bounds, percentage) {
			const ne = bounds.getNorthEast();
			const sw = bounds.getSouthWest();

			// Calculate the dimensions
			const latRange = ne.lat() - sw.lat();
			const lngRange = ne.lng() - sw.lng();

			// Calculate the inset amount (10% = 0.1)
			const latInset = latRange * percentage;
			const lngInset = lngRange * percentage;

			// Create new bounds with the inset applied
			const newSW = new google.maps.LatLng(
				sw.lat() + latInset,
				sw.lng() + lngInset
			);
			const newNE = new google.maps.LatLng(
				ne.lat() - latInset,
				ne.lng() - lngInset
			);

			return new google.maps.LatLngBounds(newSW, newNE);
		}

		function updateMarkers() {
			// Check if any coordinate is outside current bounds
			const currentBounds = map.getBounds();
			let needsRefit = false;

			coordinates.forEach(coord => {
				const position = { lat: coord.latitude, lng: coord.longitude };

				// Check if this coordinate is outside current bounds
				if (currentBounds && !shrinkBounds(currentBounds, 0.1).contains(position)) {
					console.log('here');
					needsRefit = true;
				}

				if (markers[coord.id]) {
					// Smoothly update existing marker position
					markers[coord.id].setPosition(position);
				} else {
					// Create new marker with glow effect
					markers[coord.id] = new google.maps.Marker({
						position: position,
						map: map,
						title: coord.id,
						icon: {
							path: google.maps.SymbolPath.CIRCLE,
							scale: 8,
							fillColor: coord.color || '#FF6B6B',
							fillOpacity: 0.8,
							strokeColor: '#ffffff',
							strokeWeight: 1.5,
							strokeOpacity: 0.9
						}
					});
					// New markers always trigger refit
					needsRefit = true;
				}
			});

			// Only adjust map bounds if a marker went outside
			if (needsRefit) {
				fitMapToBounds();
			}
		}

		function fitMapToBounds() {
			const bounds = new google.maps.LatLngBounds();

			// Include all coordinate points
			coordinates.forEach(coord => {
				bounds.extend({ lat: coord.latitude, lng: coord.longitude });
			});

			map.fitBounds(bounds);

			// Keep minimum zoom for detail when auto-fitting bounds
			const listener = google.maps.event.addListener(map, 'idle', () => {
				if (map.getZoom() < MIN_ZOOM) {
					map.setZoom(MIN_ZOOM);
				}
				google.maps.event.removeListener(listener);
			});
		}

		// Simulate slow walking speed (1-2 feet per second)
		function getCoordinateUpdates() {
			coordinates = coordinates.map(coord => {
				// Change direction occasionally (every ~5 seconds on average)
				if (Math.random() < 0.02) { // 2% chance per 100ms update
					// 1-2 feet per second = 0.3-0.6 meters per second
					// At equator: 1 degree latitude = 111,139 meters
					// So 0.5 meters = 0.0000045 degrees
					// This gives us movement of about 0.5 meters per second
					const speed = 0.0000145 / 10; // Divide by 10 for 100ms intervals

					// Random direction
					const angle = Math.random() * 2 * Math.PI;
					coord.velocity = {
						lat: Math.cos(angle) * speed,
						lng: Math.sin(angle) * speed
					};
				}

				// Apply velocity with some randomness for natural movement
				const randomFactor = 0.8 + Math.random() * 0.4; // 80% to 120% of velocity

				return {
					...coord,
					latitude: coord.latitude + coord.velocity.lat * randomFactor,
					longitude: coord.longitude + coord.velocity.lng * randomFactor
				};
			});

			return coordinates;
		}

		function startAnimation() {
			animationInterval = setInterval(() => {
				getCoordinateUpdates();
				updateMarkers();
			}, UPDATE_INTERVAL);
			50
		}

		// Initialize everything when the page loads
		window.onload = () => {
			loadGoogleMaps();
		};
	</script>
</body>

</html>